#Даны 𝑛 заявок на проведение занятий в некоторой аудитории. В каждой заявке
#указаны начало и конец занятия (𝑠𝑖 и 𝑓𝑖 для 𝑖-й заявки). Две заявки совместимы,
#если вторая начинается не раньше, чем заканчивается первая. Требуется выбрать
#максимальный набор совместимых заявок

def is_good(a,b):
  return a[1] <= b[0] or b[1] <= a[0] #проверяем совместимость двух заявок

# здесь определяется жадность
def next_item(heap,res):
  if len(heap) == 0: #если элементов не осталось, возвращаем None
    return None
  
  for e in heap: #если остались, ищем подходящий элемент
    flag = True
    for e2 in res: #проверять будем со всеми элементами в res
      if not is_good(e,e2): #проверка
        # если хоть с одним пересекся - уже точно не подходит
        flag = False
        break 
    if flag: # если не с кем не пересекается - подходит
      return e
  return None #не нашли - None
 

def task(l, func):
  res = []
  heap = l.copy() # оставшиеся элементы
  heap.sort(key=func)

  while True:
    
    e = next_item(heap,res)
    
    if e == None:
      break
    
    res.append(e)
    heap.remove(e)
  return res

print(task([(10,15),(1,8),(7,11)],lambda a: a[1]-a[0])) # сортировка по длине занятия
print(task([(1,25),(1,8),(8,9)],lambda a: a[0])) # сортировка по началу занятия
print(task([(10,15),(1,8),(7,11)],lambda a: a[1])) # сортировка по концу занятия
